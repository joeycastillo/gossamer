// Ported from Adafruit_GFX
// See LICENSE for license text

#include "gfx.h"
#include <string.h>
#include <stdlib.h>
#include <math.h>

#ifndef _swap_int16_t
#define _swap_int16_t(a, b)                                                    \
  {                                                                            \
    int16_t t = a;                                                             \
    a = b;                                                                     \
    b = t;                                                                     \
  }
#endif

static const unsigned char font_5x7[];
static const uint16_t font_3x5[];

int16_t gfx_raw_width = 0;
int16_t gfx_raw_height = 0;
int16_t gfx_width = 0;
int16_t gfx_height = 0;
int8_t gfx_depth = 0;
uint16_t gfx_rotation = 0;
uint8_t *gfx_buffer = NULL;

void _gfx_draw_circle_helper(int16_t x0, int16_t y0, int16_t r, uint8_t corners, uint16_t color);
void _gfx_fill_circle_helper(int16_t x0, int16_t y0, int16_t r, uint8_t corners, int16_t delta, uint16_t color);


void gfx_init(int16_t w, int16_t h, int8_t depth) {
    gfx_raw_width = w;
    gfx_raw_height = h;
    gfx_width = gfx_raw_width;
    gfx_height = gfx_raw_height;
    gfx_depth = depth;

    if (gfx_depth == 1) {
        uint32_t bytes = ((w + 7) / 8) * h;
        if ((gfx_buffer = (uint8_t *)malloc(bytes))) {
            memset(gfx_buffer, 0x00, bytes);
        }
    } else if (gfx_depth == 8) {
        uint32_t bytes = w * h;
        if ((gfx_buffer = (uint8_t *)malloc(bytes))) {
            memset(gfx_buffer, 0, bytes);
        }
    } else if (gfx_depth == 16) {
        uint32_t bytes = w * h * 2;
        if ((gfx_buffer = (uint8_t *)malloc(bytes))) {
            memset(gfx_buffer, 0, bytes);
        }
    }
}

void gfx_set_rotation(uint16_t r) {
    switch (r) {
        case 0:
        case 180:
            gfx_width = gfx_raw_width;
            gfx_height = gfx_raw_height;
            gfx_rotation = r;
            break;
        case 90:
        case 270:
            gfx_width = gfx_raw_height;
            gfx_height = gfx_raw_width;
            gfx_rotation = r;
            break;
    }
}

void gfx_draw_vline(int16_t x, int16_t y, int16_t h, uint16_t color) {
    gfx_draw_line(x, y, x, y + h - 1, color);
}

void gfx_draw_hline(int16_t x, int16_t y, int16_t w, uint16_t color) {
    gfx_draw_line(x, y, x + w - 1, y, color);
}

#define grayoled_swap(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))

static void _gfx_draw_pixel_1bit(int16_t x, int16_t y, uint16_t color) {
    switch (color) {
        case 0:
            gfx_buffer[x + (y / 8) * gfx_raw_width] &= ~(1 << (y & 7));
            break;
        case 1:
            gfx_buffer[x + (y / 8) * gfx_raw_width] |= (1 << (y & 7));
            break;
        case 3:
            gfx_buffer[x + (y / 8) * gfx_raw_width] ^= (1 << (y & 7));
            break;
    }
}

void gfx_draw_pixel(int16_t x, int16_t y, uint16_t color) {
    if ((x >= 0) && (x < gfx_width) && (y >= 0) && (y < gfx_height)) {
        // Pixel is in-bounds. Rotate coordinates if needed.
        switch (gfx_rotation) {
            case 90:
                grayoled_swap(x, y);
                x = gfx_raw_width - x - 1;
                break;
            case 180:
                x = gfx_raw_width - x - 1;
                y = gfx_raw_height - y - 1;
                break;
            case 270:
                grayoled_swap(x, y);
                y = gfx_raw_height - y - 1;
                break;
        }

        switch (gfx_depth) {
            case 1:
                _gfx_draw_pixel_1bit(x, y, color);
                break;
            case 8:
                gfx_buffer[x + y * gfx_raw_width] = (uint8_t)color;
                break;
            case 16:
                ((uint16_t *)gfx_buffer)[x + y * gfx_raw_width] = color;
                break;
        }
    }
}

void gfx_fill_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    for (int16_t i = x; i < x + w; i++) {
        gfx_draw_vline(i, y, h, color);
    }
}

void gfx_fill_screen(uint16_t color) {
    gfx_fill_rect(0, 0, gfx_width, gfx_height, color);
}

void gfx_draw_line(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) {
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);

    if (steep) {
        _swap_int16_t(x0, y0);
        _swap_int16_t(x1, y1);
    }

    if (x0 > x1) {
        _swap_int16_t(x0, x1);
        _swap_int16_t(y0, y1);
    }

    int16_t dx, dy;
    dx = x1 - x0;
    dy = abs(y1 - y0);

    int16_t err = dx / 2;
    int16_t ystep;

    if (y0 < y1) ystep = 1;
    else ystep = -1;

    for (; x0 <= x1; x0++) {
        if (steep) {
            gfx_draw_pixel(y0, x0, color);
        } else {
            gfx_draw_pixel(x0, y0, color);
        }
        err -= dy;
        if (err < 0) {
            y0 += ystep;
            err += dx;
        }
    }
}

void gfx_draw_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    gfx_draw_hline(x, y, w, color);
    gfx_draw_hline(x, y + h - 1, w, color);
    gfx_draw_vline(x, y, h, color);
    gfx_draw_vline(x + w - 1, y, h, color);
}

void gfx_draw_circle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;

    gfx_draw_pixel(x0, y0 + r, color);
    gfx_draw_pixel(x0, y0 - r, color);
    gfx_draw_pixel(x0 + r, y0, color);
    gfx_draw_pixel(x0 - r, y0, color);

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;

        gfx_draw_pixel(x0 + x, y0 + y, color);
        gfx_draw_pixel(x0 - x, y0 + y, color);
        gfx_draw_pixel(x0 + x, y0 - y, color);
        gfx_draw_pixel(x0 - x, y0 - y, color);
        gfx_draw_pixel(x0 + y, y0 + x, color);
        gfx_draw_pixel(x0 - y, y0 + x, color);
        gfx_draw_pixel(x0 + y, y0 - x, color);
        gfx_draw_pixel(x0 - y, y0 - x, color);
    }
}

void _gfx_draw_circle_helper(int16_t x0, int16_t y0, int16_t r, uint8_t corners, uint16_t color) {
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;
        if (corners & 0x4) {
            gfx_draw_pixel(x0 + x, y0 + y, color);
            gfx_draw_pixel(x0 + y, y0 + x, color);
        }
        if (corners & 0x2) {
            gfx_draw_pixel(x0 + x, y0 - y, color);
            gfx_draw_pixel(x0 + y, y0 - x, color);
        }
        if (corners & 0x8) {
            gfx_draw_pixel(x0 - y, y0 + x, color);
            gfx_draw_pixel(x0 - x, y0 + y, color);
        }
        if (corners & 0x1) {
            gfx_draw_pixel(x0 - y, y0 - x, color);
            gfx_draw_pixel(x0 - x, y0 - y, color);
        }
    }
}

void gfx_fill_circle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
    gfx_draw_vline(x0, y0 - r, 2 * r + 1, color);
    _gfx_fill_circle_helper(x0, y0, r, 3, 0, color);
}

void _gfx_fill_circle_helper(int16_t x0, int16_t y0, int16_t r, uint8_t corners, int16_t delta, uint16_t color) {
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;
    int16_t px = x;
    int16_t py = y;

    delta++; // Avoid some +1's in the loop

    while (x < y) {
    if (f >= 0) {
        y--;
        ddF_y += 2;
        f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;
    // These checks avoid double-drawing certain lines, important
    // for the SSD1306 library which has an INVERT drawing mode.
    if (x < (y + 1)) {
        if (corners & 1)
        gfx_draw_vline(x0 + x, y0 - y, 2 * y + delta, color);
        if (corners & 2)
        gfx_draw_vline(x0 - x, y0 - y, 2 * y + delta, color);
    }
    if (y != py) {
        if (corners & 1)
        gfx_draw_vline(x0 + py, y0 - px, 2 * px + delta, color);
        if (corners & 2)
        gfx_draw_vline(x0 - py, y0 - px, 2 * px + delta, color);
        py = y;
    }
    px = x;
    }
}

void gfx_draw_triangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    gfx_draw_line(x0, y0, x1, y1, color);
    gfx_draw_line(x1, y1, x2, y2, color);
    gfx_draw_line(x2, y2, x0, y0, color);
}

void gfx_fill_triangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    int16_t a, b, y, last;

    // Sort coordinates by Y order (y2 >= y1 >= y0)
    if (y0 > y1) {
        _swap_int16_t(y0, y1);
        _swap_int16_t(x0, x1);
    }
    if (y1 > y2) {
        _swap_int16_t(y2, y1);
        _swap_int16_t(x2, x1);
    }
    if (y0 > y1) {
        _swap_int16_t(y0, y1);
        _swap_int16_t(x0, x1);
    }

    if (y0 == y2) { // Handle awkward all-on-same-line case as its own thing
        a = b = x0;
        if (x1 < a)
        a = x1;
        else if (x1 > b)
        b = x1;
        if (x2 < a)
        a = x2;
        else if (x2 > b)
        b = x2;
        gfx_draw_hline(a, y0, b - a + 1, color);
            return;
    }

    int16_t dx01 = x1 - x0, dy01 = y1 - y0, dx02 = x2 - x0, dy02 = y2 - y0,
            dx12 = x2 - x1, dy12 = y2 - y1;
    int32_t sa = 0, sb = 0;

    // For upper part of triangle, find scanline crossings for segments
    // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
    // is included here (and second loop will be skipped, avoiding a /0
    // error there), otherwise scanline y1 is skipped here and handled
    // in the second loop...which also avoids a /0 error here if y0=y1
    // (flat-topped triangle).
    if (y1 == y2) last = y1; // Include y1 scanline
    else last = y1 - 1; // Skip it

    for (y = y0; y <= last; y++) {
        a = x0 + sa / dy01;
        b = x0 + sb / dy02;
        sa += dx01;
        sb += dx02;
        /* longhand:
        a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
        b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
        */
        if (a > b)
        _swap_int16_t(a, b);
        gfx_draw_hline(a, y, b - a + 1, color);
    }

    // For lower part of triangle, find scanline crossings for segments
    // 0-2 and 1-2.  This loop is skipped if y1=y2.
    sa = (int32_t)dx12 * (y - y1);
    sb = (int32_t)dx02 * (y - y0);
    for (; y <= y2; y++) {
        a = x1 + sa / dy12;
        b = x0 + sb / dy02;
        sa += dx12;
        sb += dx02;
        /* longhand:
        a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
        b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
        */
        if (a > b)
        _swap_int16_t(a, b);
        gfx_draw_hline(a, y, b - a + 1, color);
    }
}

void gfx_draw_round_rect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) {
    int16_t max_radius = ((w < h) ? w : h) / 2; // 1/2 minor axis
    if (r > max_radius) r = max_radius;

    gfx_draw_hline(x + r, y, w - 2 * r, color);         // Top
    gfx_draw_hline(x + r, y + h - 1, w - 2 * r, color); // Bottom
    gfx_draw_vline(x, y + r, h - 2 * r, color);         // Left
    gfx_draw_vline(x + w - 1, y + r, h - 2 * r, color); // Right
    // draw four corners
    _gfx_draw_circle_helper(x + r, y + r, r, 1, color);
    _gfx_draw_circle_helper(x + w - r - 1, y + r, r, 2, color);
    _gfx_draw_circle_helper(x + w - r - 1, y + h - r - 1, r, 4, color);
    _gfx_draw_circle_helper(x + r, y + h - r - 1, r, 8, color);

}

void gfx_fill_round_rect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) {
    int16_t max_radius = ((w < h) ? w : h) / 2; // 1/2 minor axis
    if (r > max_radius) r = max_radius;

    gfx_fill_rect(x + r, y, w - 2 * r, h, color);
    _gfx_fill_circle_helper(x + w - r - 1, y + r, r, 1, h - 2 * r - 1, color);
    _gfx_fill_circle_helper(x + r, y + r, r, 2, h - 2 * r - 1, color);

}

// void gfx_draw_bitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color, uint16_t bg) {
//
// }

uint8_t gfx_draw_char(int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size) {
    if ((x >= gfx_width) || (y >= gfx_height) ||
        ((x + 6 * size - 1) < 0) || ((y + 8 * size - 1) < 0)) {
        return 0;
    }

    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
        uint8_t line = font_5x7[c * 5 + i];
        for (int8_t j = 0; j < 8; j++, line >>= 1) {
            if (line & 1) {
                if (size == 1) gfx_draw_pixel(x + i, y + j, color);
                else gfx_fill_rect(x + i * size, y + j * size, size, size, color);
            } else if (bg != color) {
                if (size == 1) gfx_draw_pixel(x + i, y + j, bg);
                else gfx_fill_rect(x + i * size, y + j * size, size, size, bg);
            }
        }
    }
    if (bg != color) { // If opaque, draw vertical line for last column
        if (size == 1) gfx_draw_vline(x + 5, y, 8, bg);
        else gfx_fill_rect(x + 5 * size, y, size, 8 * size, bg);
    }

    return 6 * size;
}

uint8_t gfx_draw_small_char(int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg) {
    if ((x >= gfx_width) || (y >= gfx_height) ||
        ((x + 4 - 1) < 0) || ((y + 6 - 1) < 0)) {
        return 0;
    }

    uint16_t bitmap = font_3x5[c - 0x20];
    uint8_t advance = 4;
    if (bitmap & 1) advance = 2;
    else if (!bitmap) advance = 1;
    bitmap >>= 1;

    for (int8_t j = 14; j >= 0; j--, bitmap >>= 1) {
        if (bitmap & 1) {
            gfx_draw_pixel(x + (j % 3), y + j / 3, color);
        } else if (bg != color) {
            gfx_draw_pixel(x + (j % 3), y + j / 3, bg);
        }
    }
    if (bg != color) { // If opaque, draw lines for last row and column
        gfx_draw_hline(x, y + 5, 3, bg);
        gfx_draw_vline(x + 3, y, 6, bg);
    }

    return advance;
}

void gfx_draw_string(int16_t x, int16_t y, char *s, uint16_t color, uint16_t bg, uint8_t size) {
    int cursor_x = x;
    int cursor_y = y;
    bool wrap = false;
    for(size_t i = 0; i < strlen(s); i++) {
        unsigned char c = s[i];
        if (size == 0) {
            if (c == '\n') {
                cursor_x = x;
                cursor_y += 6;
            } else if (c != '\r') {
                if (wrap && ((cursor_x + 4) > gfx_width)) {
                    cursor_x = x;
                    cursor_y += 6;
                }
                cursor_x += gfx_draw_small_char(cursor_x, cursor_y, s[i], color, bg);;
            }
        } else {
            if (c == '\n') {
                cursor_x = x;
                cursor_y += size * 8;
            } else if (c != '\r') {
                if (wrap && ((cursor_x + size * 6) > gfx_width)) {
                    cursor_x = x;
                    cursor_y += size * 8;
                }
                cursor_x += size * gfx_draw_char(cursor_x, cursor_y, s[i], color, bg, size);;
            }
        }
    }
}

// Standard ASCII 5x7 font
static const unsigned char font_5x7[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 0x3E, 0x6B,
    0x4F, 0x6B, 0x3E, 0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x18, 0x3C, 0x7E, 0x3C,
    0x18, 0x1C, 0x57, 0x7D, 0x57, 0x1C, 0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 0x00,
    0x18, 0x3C, 0x18, 0x00, 0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 0x00, 0x18, 0x24,
    0x18, 0x00, 0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 0x30, 0x48, 0x3A, 0x06, 0x0E,
    0x26, 0x29, 0x79, 0x29, 0x26, 0x40, 0x7F, 0x05, 0x05, 0x07, 0x40, 0x7F,
    0x05, 0x25, 0x3F, 0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 0x7F, 0x3E, 0x1C, 0x1C,
    0x08, 0x08, 0x1C, 0x1C, 0x3E, 0x7F, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x5F,
    0x5F, 0x00, 0x5F, 0x5F, 0x06, 0x09, 0x7F, 0x01, 0x7F, 0x00, 0x66, 0x89,
    0x95, 0x6A, 0x60, 0x60, 0x60, 0x60, 0x60, 0x94, 0xA2, 0xFF, 0xA2, 0x94,
    0x08, 0x04, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x20, 0x10, 0x08, 0x08,
    0x2A, 0x1C, 0x08, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x1E, 0x10, 0x10, 0x10,
    0x10, 0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 0x30, 0x38, 0x3E, 0x38, 0x30, 0x06,
    0x0E, 0x3E, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F,
    0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14,
    0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23, 0x13, 0x08, 0x64, 0x62, 0x36, 0x49,
    0x56, 0x20, 0x50, 0x00, 0x08, 0x07, 0x03, 0x00, 0x00, 0x1C, 0x22, 0x41,
    0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x08,
    0x08, 0x3E, 0x08, 0x08, 0x00, 0x80, 0x70, 0x30, 0x00, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02,
    0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x72, 0x49,
    0x49, 0x49, 0x46, 0x21, 0x41, 0x49, 0x4D, 0x33, 0x18, 0x14, 0x12, 0x7F,
    0x10, 0x27, 0x45, 0x45, 0x45, 0x39, 0x3C, 0x4A, 0x49, 0x49, 0x31, 0x41,
    0x21, 0x11, 0x09, 0x07, 0x36, 0x49, 0x49, 0x49, 0x36, 0x46, 0x49, 0x49,
    0x29, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00,
    0x00, 0x08, 0x14, 0x22, 0x41, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x41,
    0x22, 0x14, 0x08, 0x02, 0x01, 0x59, 0x09, 0x06, 0x3E, 0x41, 0x5D, 0x59,
    0x4E, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x3E,
    0x41, 0x41, 0x41, 0x22, 0x7F, 0x41, 0x41, 0x41, 0x3E, 0x7F, 0x49, 0x49,
    0x49, 0x41, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x3E, 0x41, 0x41, 0x51, 0x73,
    0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x20, 0x40,
    0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x7F, 0x40, 0x40, 0x40,
    0x40, 0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x3E,
    0x41, 0x41, 0x41, 0x3E, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x3E, 0x41, 0x51,
    0x21, 0x5E, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x26, 0x49, 0x49, 0x49, 0x32,
    0x03, 0x01, 0x7F, 0x01, 0x03, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x1F, 0x20,
    0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x63, 0x14, 0x08, 0x14,
    0x63, 0x03, 0x04, 0x78, 0x04, 0x03, 0x61, 0x59, 0x49, 0x4D, 0x43, 0x00,
    0x7F, 0x41, 0x41, 0x41, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x41, 0x41,
    0x41, 0x7F, 0x04, 0x02, 0x01, 0x02, 0x04, 0x40, 0x40, 0x40, 0x40, 0x40,
    0x00, 0x03, 0x07, 0x08, 0x00, 0x20, 0x54, 0x54, 0x78, 0x40, 0x7F, 0x28,
    0x44, 0x44, 0x38, 0x38, 0x44, 0x44, 0x44, 0x28, 0x38, 0x44, 0x44, 0x28,
    0x7F, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x08, 0x7E, 0x09, 0x02, 0x18,
    0xA4, 0xA4, 0x9C, 0x78, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x44, 0x7D,
    0x40, 0x00, 0x20, 0x40, 0x40, 0x3D, 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,
    0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C, 0x04, 0x78, 0x04, 0x78, 0x7C, 0x08,
    0x04, 0x04, 0x78, 0x38, 0x44, 0x44, 0x44, 0x38, 0xFC, 0x18, 0x24, 0x24,
    0x18, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x48,
    0x54, 0x54, 0x54, 0x24, 0x04, 0x04, 0x3F, 0x44, 0x24, 0x3C, 0x40, 0x40,
    0x20, 0x7C, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x3C, 0x40, 0x30, 0x40, 0x3C,
    0x44, 0x28, 0x10, 0x28, 0x44, 0x4C, 0x90, 0x90, 0x90, 0x7C, 0x44, 0x64,
    0x54, 0x4C, 0x44, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x77, 0x00,
    0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x02, 0x01, 0x02, 0x04, 0x02, 0x3C,
    0x26, 0x23, 0x26, 0x3C, 0x1E, 0xA1, 0xA1, 0x61, 0x12, 0x3A, 0x40, 0x40,
    0x20, 0x7A, 0x38, 0x54, 0x54, 0x55, 0x59, 0x21, 0x55, 0x55, 0x79, 0x41,
    0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
    0x21, 0x55, 0x54, 0x78, 0x40, 0x20, 0x54, 0x55, 0x79, 0x40, 0x0C, 0x1E,
    0x52, 0x72, 0x12, 0x39, 0x55, 0x55, 0x55, 0x59, 0x39, 0x54, 0x54, 0x54,
    0x59, 0x39, 0x55, 0x54, 0x54, 0x58, 0x00, 0x00, 0x45, 0x7C, 0x41, 0x00,
    0x02, 0x45, 0x7D, 0x42, 0x00, 0x01, 0x45, 0x7C, 0x40, 0x7D, 0x12, 0x11,
    0x12, 0x7D, // A-umlaut
    0xF0, 0x28, 0x25, 0x28, 0xF0, 0x7C, 0x54, 0x55, 0x45, 0x00, 0x20, 0x54,
    0x54, 0x7C, 0x54, 0x7C, 0x0A, 0x09, 0x7F, 0x49, 0x32, 0x49, 0x49, 0x49,
    0x32, 0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
    0x32, 0x4A, 0x48, 0x48, 0x30, 0x3A, 0x41, 0x41, 0x21, 0x7A, 0x3A, 0x42,
    0x40, 0x20, 0x78, 0x00, 0x9D, 0xA0, 0xA0, 0x7D, 0x3D, 0x42, 0x42, 0x42,
    0x3D, // O-umlaut
    0x3D, 0x40, 0x40, 0x40, 0x3D, 0x3C, 0x24, 0xFF, 0x24, 0x24, 0x48, 0x7E,
    0x49, 0x43, 0x66, 0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 0xFF, 0x09, 0x29, 0xF6,
    0x20, 0xC0, 0x88, 0x7E, 0x09, 0x03, 0x20, 0x54, 0x54, 0x79, 0x41, 0x00,
    0x00, 0x44, 0x7D, 0x41, 0x30, 0x48, 0x48, 0x4A, 0x32, 0x38, 0x40, 0x40,
    0x22, 0x7A, 0x00, 0x7A, 0x0A, 0x0A, 0x72, 0x7D, 0x0D, 0x19, 0x31, 0x7D,
    0x26, 0x29, 0x29, 0x2F, 0x28, 0x26, 0x29, 0x29, 0x29, 0x26, 0x30, 0x48,
    0x4D, 0x40, 0x20, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x38, 0x2F, 0x10, 0xC8, 0xAC, 0xBA, 0x2F, 0x10, 0x28, 0x34, 0xFA, 0x00,
    0x00, 0x7B, 0x00, 0x00, 0x08, 0x14, 0x2A, 0x14, 0x22, 0x22, 0x14, 0x2A,
    0x14, 0x08, 0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old
                                              // code
    0xAA, 0x55, 0xAA, 0x55, 0xAA,             // 50% block
    0xFF, 0x55, 0xFF, 0x55, 0xFF,             // 75% block
    0x00, 0x00, 0x00, 0xFF, 0x00, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x14, 0x14,
    0x14, 0xFF, 0x00, 0x10, 0x10, 0xFF, 0x00, 0xFF, 0x10, 0x10, 0xF0, 0x10,
    0xF0, 0x14, 0x14, 0x14, 0xFC, 0x00, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00,
    0x00, 0xFF, 0x00, 0xFF, 0x14, 0x14, 0xF4, 0x04, 0xFC, 0x14, 0x14, 0x17,
    0x10, 0x1F, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0x1F, 0x00,
    0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10,
    0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0xFF,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x00,
    0x00, 0x00, 0xFF, 0x14, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x1F,
    0x10, 0x17, 0x00, 0x00, 0xFC, 0x04, 0xF4, 0x14, 0x14, 0x17, 0x10, 0x17,
    0x14, 0x14, 0xF4, 0x04, 0xF4, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0xF7, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x17,
    0x14, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x10,
    0x10, 0xF0, 0x10, 0xF0, 0x00, 0x00, 0x1F, 0x10, 0x1F, 0x00, 0x00, 0x00,
    0x1F, 0x14, 0x00, 0x00, 0x00, 0xFC, 0x14, 0x00, 0x00, 0xF0, 0x10, 0xF0,
    0x10, 0x10, 0xFF, 0x10, 0xFF, 0x14, 0x14, 0x14, 0xFF, 0x14, 0x10, 0x10,
    0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x38, 0x44, 0x44,
    0x38, 0x44, 0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
    0x7E, 0x02, 0x02, 0x06, 0x06, 0x02, 0x7E, 0x02, 0x7E, 0x02, 0x63, 0x55,
    0x49, 0x41, 0x63, 0x38, 0x44, 0x44, 0x3C, 0x04, 0x40, 0x7E, 0x20, 0x1E,
    0x20, 0x06, 0x02, 0x7E, 0x02, 0x02, 0x99, 0xA5, 0xE7, 0xA5, 0x99, 0x1C,
    0x2A, 0x49, 0x2A, 0x1C, 0x4C, 0x72, 0x01, 0x72, 0x4C, 0x30, 0x4A, 0x4D,
    0x4D, 0x30, 0x30, 0x48, 0x78, 0x48, 0x30, 0xBC, 0x62, 0x5A, 0x46, 0x3D,
    0x3E, 0x49, 0x49, 0x49, 0x00, 0x7E, 0x01, 0x01, 0x01, 0x7E, 0x2A, 0x2A,
    0x2A, 0x2A, 0x2A, 0x44, 0x44, 0x5F, 0x44, 0x44, 0x40, 0x51, 0x4A, 0x44,
    0x40, 0x40, 0x44, 0x4A, 0x51, 0x40, 0x00, 0x00, 0xFF, 0x01, 0x03, 0xE0,
    0x80, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x6B, 0x6B, 0x08, 0x36, 0x12, 0x36,
    0x24, 0x36, 0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00, 0x00, 0x18, 0x18, 0x00,
    0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x40, 0xFF, 0x01, 0x01, 0x00, 0x1F,
    0x01, 0x01, 0x1E, 0x00, 0x19, 0x1D, 0x17, 0x12, 0x00, 0x3C, 0x3C, 0x3C,
    0x3C, 0x00, 0x00, 0x00, 0x00, 0x00 // #255 NBSP
};

// Tom Thumb remix. Different from the one in GFX as it omits metrics that would allow for descenders.
// Still variable width, tho: low bit determines if this is a 'skinny' character (advance by 2px instead of 4).
static const uint16_t font_3x5[] = {
    0x0000,       /* 0x20 space, advance of 1 handled in a special case */
    0x9208 | 1,   /* 0x21 exclam */
    0xB400,       /* 0x22 quotedbl */
    0xBEFA,       /* 0x23 numbersign */
    0x79E4,       /* 0x24 dollar */
    0x8542,       /* 0x25 percent */
    0xDBD6,       /* 0x26 ampersand */
    0x9000 | 1,   /* 0x27 quotesingle */
    0x5244,       /* 0x28 parenleft */
    0x4494,       /* 0x29 parenright */
    0x1550,       /* 0x2A asterisk */
    0x0BA0,       /* 0x2B plus */
    0x0028,       /* 0x2C comma */
    0x0380,       /* 0x2D hyphen */
    0x0008 | 1,   /* 0x2E period */
    0x2548,       /* 0x2F slash */
    0x76DC,       /* 0x30 zero */
    0x5924,       /* 0x31 one */
    0xC54E,       /* 0x32 two */
    0xC51C,       /* 0x33 three */
    0xB792,       /* 0x34 four */
    0xF31C,       /* 0x35 five */
    0x73DE,       /* 0x36 six */
    0xE548,       /* 0x37 seven */
    0xF7DE,       /* 0x38 eight */
    0xF79C,       /* 0x39 nine */
    0x1040 | 1,   /* 0x3A colon */
    0x0828,       /* 0x3B semicolon */
    0x2A22,       /* 0x3C less */
    0x1C70,       /* 0x3D equal */
    0x88A8,       /* 0x3E greater */
    0xE504,       /* 0x3F question */
    0x57C6,       /* 0x40 at */
    0x57DA,       /* 0x41 A */
    0xD75C,       /* 0x42 B */
    0x7246,       /* 0x43 C */
    0xD6DC,       /* 0x44 D */
    0xF3CE,       /* 0x45 E */
    0xF3C8,       /* 0x46 F */
    0x73D6,       /* 0x47 G */
    0xB7DA,       /* 0x48 H */
    0xE92E,       /* 0x49 I */
    0x24D4,       /* 0x4A J */
    0xB75A,       /* 0x4B K */
    0x924E,       /* 0x4C L */
    0xBFDA,       /* 0x4D M */
    0xBFFA,       /* 0x4E N */
    0x56D4,       /* 0x4F O */
    0xD748,       /* 0x50 P */
    0x56F6,       /* 0x51 Q */
    0xD7EA,       /* 0x52 R */
    0x711C,       /* 0x53 S */
    0xE924,       /* 0x54 T */
    0xB6D6,       /* 0x55 U */
    0xB6A4,       /* 0x56 V */
    0xB7FA,       /* 0x57 W */
    0xB55A,       /* 0x58 X */
    0xB524,       /* 0x59 Y */
    0xE54E,       /* 0x5A Z */
    0xF24E,       /* 0x5B bracketleft */
    0x8880,       /* 0x5C backslash */
    0xE49E,       /* 0x5D bracketright */
    0x5400,       /* 0x5E asciicircum */
    0xE000,       /* 0x5F underscore */
    0x9000,       /* 0x60 grave */
    0x19DE,       /* 0x61 a */
    0x9ADC,       /* 0x62 b */
    0x0E46,       /* 0x63 c */
    0x2ED6,       /* 0x64 d */
    0x0EE6,       /* 0x65 e */
    0x2BA4,       /* 0x66 f */
    0x7794,       /* 0x67 g */
    0x9ADA,       /* 0x68 h */
    0x8248 | 1,   /* 0x69 i */
    0x209C,       /* 0x6A j */
    0x976A,       /* 0x6B k */
    0xC92E,       /* 0x6C l */
    0x1FFA,       /* 0x6D m */
    0x1ADA,       /* 0x6E n */
    0x0AD4,       /* 0x6F o */
    0xD6E8,       /* 0x70 p */
    0x76B2,       /* 0x71 q */
    0x0E48,       /* 0x72 r */
    0x0F3C,       /* 0x73 s */
    0x5D26,       /* 0x74 t */
    0x16D6,       /* 0x75 u */
    0x16F4,       /* 0x76 v */
    0x17FE,       /* 0x77 w */
    0x152A,       /* 0x78 x */
    0xB594,       /* 0x79 y */
    0x1DEE,       /* 0x7A z */
    0x6A26,       /* 0x7B braceleft */
    0x9248 | 1,   /* 0x7C bar */
    0xC8AC,       /* 0x7D braceright */
    0x7800,       /* 0x7E asciitilde */
    0xFFFE,       /* 0x7F full block */
};
